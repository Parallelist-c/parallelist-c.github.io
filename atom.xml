<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://parallelist-c.github.io</id>
    <title>Parallelist</title>
    <updated>2021-01-05T12:58:09.683Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://parallelist-c.github.io"/>
    <link rel="self" href="https://parallelist-c.github.io/atom.xml"/>
    <subtitle>浅い夢だから 胸をはなれない</subtitle>
    <logo>https://parallelist-c.github.io/images/avatar.png</logo>
    <icon>https://parallelist-c.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Parallelist</rights>
    <entry>
        <title type="html"><![CDATA[[NOI2018]你的名字 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/noi2018-ni-de-ming-zi/</id>
        <link href="https://parallelist-c.github.io/post/noi2018-ni-de-ming-zi/">
        </link>
        <updated>2021-01-05T09:36:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给定字符串 s 。有 q 个询问，每个询问形如 t l r ，表示查询字符串 t 中有多少个本质不同的子串在 s[l:r] 中<strong>没</strong>出现过。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">q,|s|,|t|\leq 5\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="solution">Solution</h2>
<p>将问题拆为两个部分：<br>
（1）t 中本质不同的子串<br>
（2）在 s[l:r] 中没出现过的子串</p>
<p>去重的第一想法是对于两个在 t 串中完全相同的子串，仅在第一次出现位置计算贡献。这个想法往往会因为难以找到判断是否是第一次出现而被摒弃。但是，在此题中这个想法是实用的。去重的工作可以由 SAM 实现，找到第一次出现的位置也可以通过在 parent 树上上传标记实现。<br>
子串可以视作原串一段前缀的后缀。对于一个串，我们不仅找到其第一次出现位置，更加具体地，我们把它的贡献计算在第一次出现位置的末尾位置上，也就是算作 t[1:i] 这段前缀的贡献。<br>
此时有一个重要结论：</p>
<blockquote>
<p>若 j 为最大的满足 t[j:i] 的贡献计入 t[1:i] 这段前缀的贡献的位置，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>k</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\forall k\in [1,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> ，t[k:i] 的贡献均计入 t[1:i] 这段前缀中。</p>
</blockquote>
<p>也就是满足 t[j:i] 在 t[1:i] 造成贡献的 j 一定是从 1 开始连续的一段。毕竟如果存在一个位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>p</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo>:</mo><mi>j</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">p(p\in[1:j))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的贡献计入别处 t[1:k] 的话，就说明 k 一定小于 i 。那么 t[p:i] 的所有子串都可以计入 t[1:k] 上。于是假设不成立，结论正确。<br>
有了上述结论，我们只需要对于 t 的每个位置 i ，记录最大的 j 满足 t[i:j] 的贡献计入 i 的 j 就行了。</p>
<p>接着考虑如何找在 s[l:r] 中没出现过的子串。对 s 建 SAM ，并利用可持久化版的线段树合并维护 SAM 上每个节点的 endpos 集合。此时，我们已经可以判定某个长度为 len 的串是否在 s[l:r] 中出现了——找到对应的节点，并在该点的线段树上查询 [l+len-1,r] 内是否有一个 endpos 。<br>
用 t 串来匹配 s 串。固定右端点 R ，找到最远的，满足 t[L:R] 在 s 中出现过的 L 。于是可以发现对于固定的右端点 R 而言，不满足 t[L:R] 在 s 中出现过的 L 恰好也是一段前缀！也就是说，如果我们能找到这个 L ，那么就只需要与上面计入贡献的那个 j 取 min 就行了。<br>
怎么在 SAM 上匹配字符串呢？考虑跳 link 边本质上是丢弃一段已匹配的前缀。当现有的前缀无法满足加入第 R+1 个字母的需求时，我们不妨丢弃一段前缀，剩下的后缀更加灵活，更有可能允许加入第 R+1 个字符。故我们能接就接，不能接就跳 link 。需要注意的是，本题中的匹配只允许在 s[l:r] 中找，当这个区间中没有转移后的字符串时，我们也必须再跳 link 。</p>
<p>有一个小细节：尽管我在叙述时用的是跳 link ，但实际并非如此。 SAM 上的一个节点维护了若干个字符串，也许当丢弃了一段前缀后的字符串仍然在该节点中，此时无需跳 link 边。务必要小心。</p>
<p>对于一个 R ，前后两次求出来的 L 取 min 即为该位置上的答案。</p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(|s|\log_2{|s|})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span></span><span class="mclose">)</span></span></span></span> 。</p>
<h2 id="code">Code</h2>
<p>实现的有点丑陋... 第一次写码农字符串题🤢...</p>
<pre><code class="language-cpp">const int N=1e6+5;
using namespace std;
namespace SEG{
#define mid (l+r&gt;&gt;1)
#define ls c[p][0],l,mid
#define rs c[p][1],mid+1,r
    int tot;
    int t[N&lt;&lt;5],c[N&lt;&lt;5][2];
    void modify(int &amp;p,int l,int r,int pos){
        p=++tot;t[p]=1;
        if(l==r) return void();
        if(pos&lt;=mid) modify(ls,pos);
        else modify(rs,pos);
    }
    void merge(int &amp;p,int x,int l,int r){
        if(p==0||x==0) return p=x+p,void();
        int cur=++tot;
        t[cur]=t[p]+t[x],c[cur][0]=c[p][0],c[cur][1]=c[p][1];
        p=cur;
        if(l==r) return;
        merge(c[p][0],c[x][0],l,mid);
        merge(c[p][1],c[x][1],mid+1,r);
    }
    int query(int p,int l,int r,int nl,int nr){
        if(l&gt;=nl&amp;&amp;r&lt;=nr) return t[p];
        int ret=0;
        if(mid&gt;=nl) ret+=query(ls,nl,nr);
        if(mid&lt; nr) ret+=query(rs,nl,nr);
        return ret; 
    }
    void print(int p,int l,int r){
        if(l==r) printf(&quot;%d &quot;,l);
        if(t[c[p][0]]) print(ls);
        if(t[c[p][1]]) print(rs);
    }
}
namespace SAM1{
    int t[N],A[N],rk[N],rt[N];
    int las,tot,len;
    struct SAM{
        int l,link,c[26];
    }a[N];
    void insert(int k,int i){
        int p=las,cur=las=++tot;SEG::modify(rt[cur],1,len,i);
        a[cur].l=a[p].l+1;
        while(p&amp;&amp;!a[p].c[k]) a[p].c[k]=cur,p=a[p].link;
        if(p==0) return a[cur].link=1,void();
        int q=a[p].c[k];
        if(a[q].l==a[p].l+1) return a[cur].link=q,void();
        int now=++tot;
        a[now]=a[q];a[now].l=a[p].l+1,a[cur].link=a[q].link=now;
        while(p&amp;&amp;a[p].c[k]==q) a[p].c[k]=now,p=a[p].link;
    }
    void basesort(){
        for(int i=1;i&lt;=tot;++i) ++t[a[i].l];
        for(int i=1;i&lt;=len;++i) t[i]+=t[i-1];
        for(int i=1;i&lt;=tot;++i) rk[t[a[i].l]--]=i;
    }
    void solve(char *s){
        las=tot=1;
        len=strlen(s+1);
        for(int i=1;i&lt;=len;++i)
            insert(s[i]-'a',i);
        basesort();
        for(int i=tot;i&gt;=2;--i){
            int u=rk[i];
            SEG::merge(rt[a[u].link],rt[u],1,len);
        }
    }
    void match(char *s,int l,int r){
        int leng=strlen(s+1),L=1,R=0;
        for(int i=1,u=1;i&lt;=leng;++i){
            while((L&lt;=R)&amp;&amp;!SEG::query(rt[a[u].c[s[i]-'a']],1,len,l+(R-L+1),r)){
                ++L;
                if(a[u].link&amp;&amp;a[a[u].link].l&gt;=R-L+1)
                    u=a[u].link;
            }
            if(SEG::query(rt[a[u].c[s[i]-'a']],1,len,l+(R-L+1),r)) 
                u=a[u].c[s[i]-'a'];
            else ++L;
            A[++R]=L-1;
        }
    }
}
namespace SAM2{
    int t[N],B[N],rk[N],pos[N];
    int las,tot,len;
    struct SAM{
        int l,link,c[26];
    }a[N];
    void reset (int p){
        memset(a[p].c,0,sizeof a[p].c);
        a[p].link=a[p].l=0;
    }
    void insert(int k){
        int p=las,cur=las=++tot;reset(tot);
        a[cur].l=a[p].l+1;
        while(p&amp;&amp;!a[p].c[k]) a[p].c[k]=cur,p=a[p].link;
        if(p==0) return a[cur].link=1,void();
        int q=a[p].c[k];
        if(a[q].l==a[p].l+1) return a[cur].link=q,void();
        int now=++tot;reset(tot);
        a[now]=a[q];a[now].l=a[p].l+1,a[cur].link=a[q].link=now;
        while(p&amp;&amp;a[p].c[k]==q) a[p].c[k]=now,p=a[p].link;
    }
    void basesort(){
        for(int i=1;i&lt;=tot;++i) ++t[a[i].l];
        for(int i=1;i&lt;=len;++i) t[i]+=t[i-1];
        for(int i=1;i&lt;=tot;++i) rk[t[a[i].l]--]=i;
        for(int i=1;i&lt;=tot;++i) t[a[i].l]=0; 
    }
    void solve(char *s){
        las=tot=1;reset(1);
        len=strlen(s+1);
        for(int i=1;i&lt;=len;++i)
            insert(s[i]-='a');
        for(int i=1;i&lt;=tot;++i) pos[i]=0x3f3f3f3f;
        for(int i=1,u=1;i&lt;=len;++i){
            u=a[u].c[int(s[i])];
            pos[u]=i;
            B[i]=0x3f3f3f3f;
        }
        basesort();
        for(int i=tot,u=rk[i];i&gt;=1;--i,u=rk[i])
            pos[a[u].link]=min(pos[a[u].link],pos[u]);
        for(int i=1,u=rk[i];i&lt;=tot;++i,u=rk[i])
            B[pos[u]]=min(B[pos[u]],a[a[u].link].l);
        for(int i=1;i&lt;=len;++i)
            B[i]=i-B[i];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF526D Om Nom and Necklace 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/cf526d-om-nom-and-necklace-jie-ti-bao-gao/</id>
        <link href="https://parallelist-c.github.io/post/cf526d-om-nom-and-necklace-jie-ti-bao-gao/">
        </link>
        <updated>2021-01-04T10:45:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给定长度为 n 的字符串 s ，对于 s 的每个前缀，求该前缀是否能满足 AB...ABA 的形式，其中 A 恰好有 k+1 个，B 恰好有 k 个 。A B 可以是任意字符串，或者为空串；k 是给定的。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1\leq n,k\leq 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="solution">Solution</h2>
<p>非常直观的想法就是将 AB 视作一个整体，再在最后加个 A 。<br>
由于 k 是给定的，当循环节长度也给定时，前缀是确定的。故我们可以枚举循环节长度 c ，然后判定 s[1:ck] 是否为循环节次数为 k 的严格循环子串。如何快速判定呢？考虑当 s[1:ck] 符合要求时， s[1:c(k-1)]=s[k+1:ck] ，并且互为充分必要条件。正着非常直观，反过来证明可以这样考虑：s[1:k]=s[k+1:2k]=s[2k+1:3k]=... 。类似于错位相消？ 🤔</p>
<p>由上可知一个重要的 trick ：</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mtext>Z</mtext><mi>k</mi></msub><mo>≥</mo></mrow><annotation encoding="application/x-tex">\text{Z}_{k}\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">Z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span></span></span></span> c(k-1) 与 s[1:ck] 为循环节次数为 k 的严格循环子串互为充要条件。</p>
</blockquote>
<p>插句闲话，如果要判断 s[l,r] 是否为循环节长度为 k 的严格循环子串时可以哈希判断 s[l:r-k] 和 s[l+k:r] 是否相等。证明方法与上述错位相消类似。</p>
<p>回到这个题，我们已经求出来了所有循环节长度恰好为 c 的位置，现在再考虑如何在 s[ck] 后插入 A 。显然， A 的长度小于等于 c ，并且在 c 中出现过。这不恰好就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>min</mtext><mo>(</mo><msub><mtext>Z</mtext><mrow><mi>c</mi><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{min}(\text{Z}_{ck+1},c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">min</span></span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">Z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span> 嘛。并且可以发现是一整段一整段的符合条件，所以直接差分维护就行了。<br>
算法复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 。</p>
<p>事实上，对于 ABA...A 的串，一种更加直观的想法是直接 kmp 求 border 。kmp 求出来的非严格循环节形式上也更像。但是由于此题限制了循环次数为 k ，似乎除了暴力跳 fail 也没有什么好的枚举办法。<br>
其实不然。我们设当前枚举到第 i 位。当前的最长 border 为 fail[i] ，周期为 T=i-fail[i] ，循环次数为 d=i/(i-fail[i]) 下取整。鉴于我们需要的循环次数为 k ，我们直接钦定每 d/k （下取整） 个小循环为一个大循环， 剩下的 d mod k 个小循环为 A 。<br>
当 i 恰好为若干次小循环时，B 可以为空串；否则的话，B 不能为空串。<br>
算法复杂度也是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 。</p>
<p>代码采用的是第二种方法。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">for(int i=1;i&lt;=len;++i){
        int d=i/(i-fail[i]);
        if(i%(i-fail[i])) putchar((d/k-d%k&gt;0)+'0');
        else putchar((d/k-d%k&gt;=0)+'0');
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Luogu4173 残缺的字符串 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/luogu4173-can-que-de-zi-fu-chuan-jie-ti-bao-gao/</id>
        <link href="https://parallelist-c.github.io/post/luogu4173-can-que-de-zi-fu-chuan-jie-ti-bao-gao/">
        </link>
        <updated>2021-01-03T10:47:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给定长度为 n 的字符串 A 和长度为 m 的字符串 B 。当以 A 为模式串时，你希望求出对于 B 的每一个位置 i ，从该位置开始的连续 n 个字符形成的子串是否能与 A 完全匹配。A B 中可能含有通配符 @ 。通配符可以视作为任意小写字母。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\leq n\leq m\leq 3\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="solution">Solution</h2>
<p><s>《字符串哲学中的多项式方法》</s><br>
多项式方法在字符串匹配问题中的应用也很广泛。<br>
比较常见的一种类型是将字符映射成特定的值，使得卷积后数组位置上的值有特殊的含义。这种方法很灵活。<br>
在本题中，我们先随机给字符（除通配符外）映射成一个值，将 A 中的字母映射成该值，B 中的字母映射成该值的逆元。那么，当没有通配符时，我们需要求解这样一个数组：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mrow><msub><mi>A</mi><mi>j</mi></msub><mo>×</mo><msub><mi>B</mi><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">f_i=\sum_{j=0}^{m}{A_j\times B_{i+j}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">f_i=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 时，意味着 i 位置是可行的。<br>
观察到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的求解是减法逆元的形式。我们令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><msub><mi>A</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_i=A_{m-1-i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> ，则：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mrow><msub><mi>A</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>j</mi></mrow></msub><mo>×</mo><msub><mi>B</mi><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msub></mrow><mo>=</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>i</mi></mrow></munder><msub><mi>A</mi><mi>j</mi></msub><mo>×</mo><msub><mi>B</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">f_i=\sum_{j=0}^{m}{A_{m-1-j}\times B_{i+j}}=\sum_{j+k=m-1+i}A_j\times B_k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.488226em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>NTT 可以做。<br>
通配符一定可以匹配上，所以我们并不需要通配符与其对应位参与该运算中，而可以在事后统计。于是我们将通配符映射为 0 ，并在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,i+m-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中通配符的数量 。<br>
但是有可能恰好两个通配符匹配上了，此时理应只算一次贡献。这部分的容斥显然可以通过仅将通配符设为 1 后卷积得到，方法与上述求解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 类似，不再赘述。</p>
<p>另外一种方法是构造新运算。定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">m(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">A_x,B_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 是否匹配，若匹配则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m(x,y)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ；否则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mi mathvariant="normal">≠</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">m(x,y)\ne 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 。<br>
考虑到我们是这样判定两个子串是否相等的：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>m</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>=</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[\sum_{i=0}^{n}m(i,i)=0]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mopen">[</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span></p>
<p>故我们需要该运算的结果满足非负性/非正性（防止抵消），并且可以兼容通配符。<br>
其实从非负性/非正性就可以大致得出来了，我们可以如下构造 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">m()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 运算：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><msub><mi>A</mi><mi>x</mi></msub><msub><mi>B</mi><mi>y</mi></msub><mo>(</mo><msub><mi>A</mi><mi>x</mi></msub><mo>−</mo><msub><mi>B</mi><mi>y</mi></msub><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">m(x,y)=A_xB_y(A_x-B_y)^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.150216em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>并将通配符定义为 0 。<br>
于是我们需要求的</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>m</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g_i=\sum_{j=0}^{n}m(i,i+j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span></p>
<p>也可以通过暴力展开括号后减法卷积求得。最后的结果为（设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><msub><mi>A</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_i=A_{m-1-i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>）：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>i</mi></mrow></munder><msubsup><mi>C</mi><mi>j</mi><mn>3</mn></msubsup><msub><mi>A</mi><mi>k</mi></msub><mo>+</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>i</mi></mrow></munder><msubsup><mi>C</mi><mi>j</mi><mn>2</mn></msubsup><msubsup><mi>A</mi><mi>k</mi><mn>2</mn></msubsup><mo>+</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>+</mo><mi>k</mi><mo>=</mo><mi>i</mi></mrow></munder><msub><mi>C</mi><mi>j</mi></msub><msubsup><mi>A</mi><mi>k</mi><mn>3</mn></msubsup></mrow><annotation encoding="application/x-tex">g_i=\sum_{j+k=i}C_j^3A_k+\sum_{j+k=i}C_j^2A_k^2+\sum_{j+k=i}C_jA_k^3
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.488226em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.488226em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.488226em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>代码采用的是第一种方法。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">int main(){

    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);
    scanf(&quot;%s&quot;,t);scanf(&quot;%s&quot;,s);

    srand(19260817);
    for(int i=0;i&lt;26;++i)
        d[i]=max(rand()%Mod,2),invd[i]=Q(d[i],Mod-2); // 注意随机化的值不能为 0
    
    for(int i=0;i&lt;m;++i) f[i]=t[i]=='*';
    for(int i=0;i&lt;n;++i) g[i]=s[i]=='*';
    reverse(f,f+m);
    Getmul(f,g,h,m,n);

    int sum=0;
    szs[0]=s[0]=='*';
    for(int i=1;i&lt;n;++i) 
        szs[i]=szs[i-1]+(s[i]=='*');
    for(int i=0;i&lt;m;++i) sum+=t[i]=='*';
    for(int i=0;i&lt;m;++i) f[i]=t[i]=='*'?0:d[t[i]-'a'];
    for(int i=0;i&lt;n;++i) g[i]=s[i]=='*'?0:invd[s[i]-'a'];
    reverse(f,f+m);
    Getmul(f,g,l,m,n);

    for(int i=0;i&lt;=n-m;++i)
        if(l[i+m-1]-h[i+m-1]+sum+szs[i+m-1]-(i==0?0:szs[i-1])==m) 
            ans.push_back(i+1);
    printf(&quot;%d\n&quot;,ans.size());
    for(auto x:ans)
        printf(&quot;%d &quot;,x);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HNOI2004]L语言 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/hnoi2004l-yu-yan/</id>
        <link href="https://parallelist-c.github.io/post/hnoi2004l-yu-yan/">
        </link>
        <updated>2021-01-03T04:45:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给定一个由 n 个字符串 s 组成的字典，再给定 m 句话 t ，求每句话在该字典下可以理解的最长前缀。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>20</mn><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>50</mn><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>10</mn><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n\leq 20,m\leq 50,|s|\leq 10,|t|\leq 2\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="solution">Solution</h2>
<p>考虑朴素做法。设 f[i] 表示 t[1:i] 能否被理解。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><munder><mo>⋃</mo><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mo>(</mo><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo><mtext> and </mtext><mo>[</mo><mi>t</mi><mo>[</mo><mi>i</mi><mo>:</mo><mi>j</mi><mo>]</mo><mtext>in</mtext><mo>{</mo><mi>s</mi><mo>}</mo><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f[i]= \bigcup\limits_{j&lt;i} (f[j] \text{ and } [t[i:j] \text{in} \{s\}]) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord text"><span class="mord"> and </span></span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord text"><span class="mord">in</span></span><span class="mopen">{</span><span class="mord mathdefault">s</span><span class="mclose">}</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>如果采用哈希判断，复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(m|s||t|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> ，有点卡常。</p>
<p>题目中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">|s|\leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 的范围很有特点，这意味着每次向前至多只会比较 10 次。<br>
抛开哈希，我们重新考虑匹配的过程。对 s 串建 AC 自动机，当匹配 t[i] 时，假设在 AC 自动机上走到了 u 节点。若 u 有 end 标记，我们就再回到 t 串查询对应的 f[j] 是否为 true ；否则，我们就遍历 fail[u] ，直到找到一个两者均为 true 的位置或者找到根节点。在这个过程中，我们只需要 f<a href="j%3Ci">j</a> 以及 u 在 fail 树上的所有祖先的 end 标记信息。由于 fail 树树高不超过 10 ，所以两者我们都可以状压。即令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>a</mi><mi>s</mi><mo>=</mo><msup><mn>2</mn><mi>i</mi></msup><mo>×</mo><mo>[</mo><msub><mi>f</mi><mrow><mi>j</mi><mo>−</mo><mi>i</mi></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">las=2^i\times[f_{j-i}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>u</mi></msub><mo>=</mo><msub><mi>g</mi><msub><mtext>fa</mtext><mi>u</mi></msub></msub><mo>+</mo><mo>(</mo><msup><mn>2</mn><msub><mtext>len</mtext><mi>u</mi></msub></msup><mo>×</mo><mo>[</mo><mtext>end</mtext><mo>[</mo><mi>u</mi><mo>]</mo><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">g_u=g_{\text{fa}_u}+(2^{\text{len}_u}\times [\text{end}[u]])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83343em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">fa</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">len</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord text"><span class="mord">end</span></span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 。</p>
<p>于是就可以做到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 判断了。复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>m</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(m|t|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord">∣</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span> 。</p>
<p><s>本质就是通过状压卡常数而已 😶。10 只是方便了一个 int 可以压下来，任意长度都可以状压。</s></p>
<p>但是如果哈希就无法卡常了... 所以说将匹配过程看作在 fail 树上跳，由于树是可以预处理出来的，并且树上算法还是挺成熟的，没准可以有奇效。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">const int N=1e3+5,L=2e6+5;
using namespace std;
int n,m;
namespace ACM{
    int tot;
    int g[N],dep[N],fail[N],endpos[N],t[N][26];
    void insert(char *s){
        int len=strlen(s),u=0;
        for(int i=0;i&lt;len;++i){
            int v=s[i]-'a';
            if(!t[u][v]) t[u][v]=++tot,dep[tot]=dep[u]+1;
            u=t[u][v]; 
        }
        endpos[u]=1;
    }
    void prework(){
        queue&lt;int&gt;q;int u=0;
        for(int i=0;i&lt;26;++i)
            if(t[u][i]) q.push(t[u][i]),g[t[u][i]]=endpos[t[u][i]];
        while(!q.empty()){
            u=q.front();q.pop();
            for(int i=0;i&lt;26;++i)
                if(!t[u][i]) t[u][i]=t[fail[u]][i];
                else{
                    int v=t[u][i];fail[v]=t[fail[u]][i];
                    g[v]=g[fail[v]]|(endpos[v]&lt;&lt;dep[v]-1);q.push(v);
                }
        }
    }
    int solve(char *s){
        int len=strlen(s),u=0,lst=1,ans=0;
        for(int i=0;i&lt;len;++i){
            u=t[u][s[i]-'a'];
            bool now=(g[u]&amp;lst);
            lst&lt;&lt;=1,lst|=now,lst&amp;=1023;
            if(now) ans=i+1;
        }
        return ans;
    }
}
char s[N],t[L];
int main(){

    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;++i)
        scanf(&quot;%s&quot;,s),ACM::insert(s);
    ACM::prework();
    for(int i=1;i&lt;=m;++i)
        scanf(&quot;%s&quot;,t),printf(&quot;%d\n&quot;,ACM::solve(t));
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HAOI2009]求回文串 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/haoi2009qiu-hui-wen-chuan-jie-ti-bao-gao/</id>
        <link href="https://parallelist-c.github.io/post/haoi2009qiu-hui-wen-chuan-jie-ti-bao-gao/">
        </link>
        <updated>2021-01-03T01:38:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给定长度为 n 的字符串 s ，每次只能交换相邻两个位置。求使得 s 为回文串的最小交换次数。无解输出 -1 。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n\leq 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，保证都是大写字母</p>
<h2 id="solution">Solution</h2>
<p>无解的情况判定：讨论 n 的奇偶性以及 s 中各字母的出现次数的奇偶性即可。</p>
<p>对于“每次只能交换相邻两个位置，求最小交换次数”的题目，通常采取的办法为得到目标序列，并定义 las[i] 表示初始序列中的第 i 个数最终应在目标序列的 las[i] 位置上。 las 数组的逆序对数即为答案。</p>
<p>问题转化为求解目标序列。假设我们在处理字母 x 时遇到了下述情况。x 的出现位置为 a,b,c,d 。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots,a,\cdots,b,\cdots,c,\cdots,d,\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span></p>
<p>事实上，我们固定 a b 不变，让 d 去适配 a 的位置，c 去适配 b 的位置一定是最优的。<br>
假设我们让 c 适配 a ，d 适配 b，那么无论如何 c d 都会相遇一次。而 c d 本质上是同一个东西，也就是说相遇之后走的距离完全是多余的。</p>
<p>于是我们得到了适配同一字母的所有的位置的方法。</p>
<p>对于不同的字母呢？考虑下述情况，其中 c d 分别表示 a b 的对称位置。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots,a,\cdots,b,\cdots,c,\cdots,d,\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span></p>
<p>交换 a b 的位置是否可以更优？我们考虑 a 适配的位置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">p_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，b 适配的位置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">p_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，显然，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>a</mi></msub><mo>≥</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">p_a\geq d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>b</mi></msub><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">p_b\leq c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 时，可以使交换 a b 的位置后减少的步数最大化（单论步数的变换量而言的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span> 是等效的）。但是，即使是这种情况下（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>a</mi></msub><mo>=</mo><mi>d</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>b</mi></msub><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">p_a=d,p_b=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>），交换与否步数也只是恰好相等。故对于两个不同的字母，不交换一定不劣于交换。</p>
<p>综上，我们可以贪心地构造出 las 数组。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">if(num==1){
    for(int i=0;i&lt;26;++i) if(d[i]&amp;1){
        int now=p[i][p[i].size()/2];
        las[len+1&gt;&gt;1]=now;vis[now]=1;
    } 
}
int idx=1,nl=1,nr=len;
while(idx&lt;=len&amp;&amp;nl&lt;=nr){
    if(vis[idx]) {++idx;continue;}
    int mat=p[s[idx]].back();
    las[nl]=idx,las[nr]=mat,p[s[idx]].pop_back();
    ++nl,--nr,vis[mat]=1;++idx;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PAM 学习笔记]]></title>
        <id>https://parallelist-c.github.io/post/PAM-xue-xi-bi-ji/</id>
        <link href="https://parallelist-c.github.io/post/PAM-xue-xi-bi-ji/">
        </link>
        <updated>2021-01-02T02:54:21.000Z</updated>
        <content type="html"><![CDATA[<p>回文自动机（PAM）是针对给定串，包含了该串所有回文子串的信息的自动机。<br>
PAM 的每个节点代表了一个本质不同的回文子串，记 s[p] 为点 p 代表的回文子串。<br>
PAM 的每个节点有三个基础属性：fail/len/child 。<br>
len：a[p].len 表示 s[p] 的长度。<br>
fail：a[p].fail 连向了点 x ，满足 s[x] 是 s[p] 的最长后缀回文子串。<br>
child：a[p].child[v] 连向了点 x ，满足 s[x] 恰是 v+s[p]+v 。因此转移时 len 会加二。</p>
<p>由于回文串有奇偶之分，所以我们需要建立两个根：-1 和 0 ，分别为奇根和偶根。奇根的 len 为 -1 ，代表 -1 串（方便插入单个字符构成的回文串）；偶根的 len 为 0 ，代表空串。奇根的 fail 可以任意连，而偶根的 fail 定义为连向奇根。</p>
<p>现在给定字符串 t ，我们考虑使用增量法来构造 PAM 。<br>
假设新加入的位置为 v ，上一个权值加入后在 SAM 上的位置是 las 。v 可以构成的回文子串可以视作 t[v']+mid+t[v] 的形式，其中 mid 部分也为回文串。故我们从 las 开始，若满足 t[v]=t[v-a[las].len-1] ，意味着我们找到了对应的最大回文串；否则执行 las=a[las].fail 并重新检验。因为 fail 指向的是最长的后缀回文子串，所以我们必定会经过所有可能。<br>
假设我们找到了满足 t[v]=t[v-a[las].len-1] 的 las ，此时有两种可能：</p>
<ul>
<li>a[las].c[t[v]] 已存在。此时 v 对于不同种类的回文子串而言无任何贡献。</li>
<li>a[las].c[t[v]] 未存在。此时发现了新的回文子串。新建节点并初始化其 len/fail 值即可。</li>
</ul>
<p>构建代码：</p>
<pre><code class="language-cpp">namespace PAM{
    int s[N];
    int tot,las,top;
    struct PAM{
        int len,sum,fail,c[26];
    }a[N];
    void init(){
        tot=1,las=0,top=0;
        a[0].len=0,a[1].len=-1;
        a[0].fail=a[1].fail=1;
        memset(s,-1,sizeof s);
    }
    int getfail(int x,int p){
        while(s[p]!=s[p-a[x].len-1])
            x=a[x].fail;
        return x; 
    }
    void insert(int v){
        s[++top]=v;
        int cur=getfail(las,top);
        if(a[cur].c[v]==0){
            ++tot;
            a[tot].len=a[cur].len+2;
            a[tot].fail=a[getfail(a[cur].fail,top)].c[v];
            a[cur].c[v]=tot;
        }
        las=a[cur].c[v];
    }
}
</code></pre>
<p>接着总结下 PAM 的一些应用。</p>
<p>本质不同的回文串个数：这个显然就是 tot-1 。</p>
<p>回文串的出现次数：构建 PAM 时我们只统计了极长的该回文串的数量，但其他情况可以一定可以通过跳 fail 统计到。考虑 insert(a[i]) 后若新增节点代表的是 s[j...i] ，那么所有以 i 结尾的回文子串必定是 s[j...i] 的后缀子串。拓扑排序后 dp 即可。</p>
<p>与 PAM 配套的有一个 trans 指针，定义为指向小于等于当前节点长度的一半的最长回文后缀。<br>
求解 trans 的方法与 fail 类似。从父节点的 trans 开始检验，如果当前并不能构成回文子串/长度大于一半，就继续跳 fail 。</p>
<p>PAM 的拓展性没有 SAM 强，但也十分灵活。DFA 这种东西，平常一定要多加深理解啊 👊 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Query on a tree VI 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/query-on-a-tree-vi-jie-ti-bao-gao/</id>
        <link href="https://parallelist-c.github.io/post/query-on-a-tree-vi-jie-ti-bao-gao/">
        </link>
        <updated>2020-12-29T12:06:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给你一棵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点的树，每个点为黑色或白色。要求维护两个操作：</p>
<ul>
<li>改变点 u 的颜色</li>
<li>查询包含点 u 的同色连通块大小</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n,q\leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="solution">Solution</h2>
<p>动态维护连通块可以考虑 LCT 。但是当一个点颜色改变时如果我们枚举其所有出边来更改，复杂度爆炸。</p>
<p>平常都是把边的信息放在点上，因为边数比点数少，信息一定不会有缺失；很少把点的信息放在边上。<br>
实际上，点的信息也是可以放在边上的。对于非根节点，每个点的信息放在父边上；对于根节点，我们另开一个虚拟根节点与其连边用来存根节点的信息。</p>
<p>具体于本题而言，我们建两棵 LCT ，分别代表黑/白色。在 LCT 中，我们只加入对应颜色的边。点 u 在颜色 c[u] 对应的 LCT 上的最远祖先一定是虚拟节点/异色节点，即 findroot(u) 后，根的重子树大小就是包含点 u 的同色连通块大小（因为 findroot 中 splay 了根节点）。根的重儿子必定是其右儿子。</p>
<p>问题转化为维护 LCT 上 u 的子树大小，维护一个 vir[u] 表示连向 u 的所有轻链 size 即可。</p>
<p>需要注意的是，在本题中，树的形态是固定的，也就是我们不能进行 makeroot 操作。但庆幸的是，经过上述分析后，我们可以发现 link 和 cut 操作都是恰好针对点 u 和其父节点来的，故仍然可以实现。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">struct LCT{
#define lc(x) c[x][0]
#define rc(x) c[x][1]
    int sz[N],fa[N],vir[N],c[N][2];
    LCT(){for(int i=1;i&lt;N;++i) sz[i]=1;}
    inline void update(int x){
        sz[x]=sz[lc(x)]+sz[rc(x)]+vir[x]+1;
    }
    inline bool isrt(int x){
        return fa[x]==0 || (lc(fa[x])!=x&amp;&amp;rc(fa[x])!=x);
    }
    inline void rotate(int x){
        int y=fa[x],z=fa[y],t=rc(y)==x;
        if(!isrt(y)) c[z][rc(z)==y]=x;fa[x]=z;
        c[y][t]=c[x][t^1];fa[c[x][t^1]]=y;
        c[x][t^1]=y;fa[y]=x;
        update(y),update(x);
    }
    void splay(int x){
        while(!isrt(x)){
            int y=fa[x],z=fa[y];
            if(!isrt(y))
                ((rc(y)==x)^(rc(z)==y))?rotate(x):rotate(y);
            rotate(x);
        }
    }
    void access(int x){
        for(int i=0;x;x=fa[i=x])
            splay(x),vir[x]+=sz[rc(x)],rc(x)=i,vir[x]-=sz[i],update(x);
    }
    int findrt(int x){                          
        access(x);splay(x);
        while(lc(x)) 
            x=lc(x);
        splay(x);
        return x;
    }
    void link(int x,int y){
        splay(x);fa[x]=y;
        access(y),splay(y);
        vir[y]+=sz[x];sz[y]+=sz[x];
    }
    void cut(int x,int y){
        access(x),splay(x),lc(x)=fa[lc(x)]=0;update(x);
    }
}t[2];
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[AHOI2005] 航线规划 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/ahoi2005-hang-xian-gui-hua/</id>
        <link href="https://parallelist-c.github.io/post/ahoi2005-hang-xian-gui-hua/">
        </link>
        <updated>2020-12-29T06:13:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给定一张图，需要支持两个操作：</p>
<ul>
<li>查询 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 两点间的必经边数量。</li>
<li>删除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 直接相连的边，保证一定存在。</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n\leq 3\times 10^4,m\leq 10^5,q\leq 4\times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="solution">Solution</h2>
<p>首先可以发现题目本质是要求动态维护边双树，边双树上的删边操作并不好处理，我们将询问离线下来转化为加边操作，这样可以通过缩点在上限为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间内维护树的形态。<br>
假如我们已经构建出来了边双树，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 两点间的必经边数量就是两点在边双树上的距离。<br>
我们可以方便地在 LCT 上动态维护两点的距离，于是可以用 LCT 来维护边双树。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">int Find(int x){return x==uni[x]?x:uni[x]=Find(uni[x]);}
namespace LCT{
#define lc(x) c[x][0]
#define rc(x) c[x][1]
    int s[N],sz[N],fa[N],rev[N],c[N][2];
    bool isrt(int x){
        return fa[x]==0 || (lc(fa[x])!=x&amp;&amp;rc(fa[x])!=x);
    }
    void update(int x){
        sz[x]=sz[lc(x)]+sz[rc(x)]+1;
    }
    void revers(int x){
        swap(lc(x),rc(x));rev[x]^=1;
    }
    void pushdn(int x){
        if(rev[x]==0) return;
        revers(lc(x));revers(rc(x));
        rev[x]=0;
    }
    void rotate(int x){
        int y=fa[x],z=fa[y],t=rc(y)==x;
        if(!isrt(y)) c[z][rc(z)==y]=x;fa[x]=z;
        c[y][t]=c[x][t^1];fa[c[x][t^1]]=y;
        c[x][t^1]=y;fa[y]=x;
        update(y),update(x);
    }
    void splay(int x){
        int top,y=x;s[top=1]=x;
        while(!isrt(y)) y=fa[y],s[++top]=y;
        while(top) pushdn(s[top--]);
        while(!isrt(x)){
            int y=fa[x],z=fa[y];
            if(!isrt(y))
                ((rc(y)==x)^(rc(z)==y))?rotate(x):rotate(y);
            rotate(x);
        }
    }
    void access(int x){
        for(int i=0;x;x=fa[i=x]=Find(fa[x]))   //可能父节点已经被缩了
            splay(x),rc(x)=i,update(x);
    }
    void makert(int x){
        access(x),splay(x),revers(x);
    }
    int  findrt(int x){
        access(x);splay(x);
        while(lc(x)) 
            pushdn(x=lc(x));
        splay(x);
        return x;
    }
    void split(int x,int y){
        makert(x),access(y),splay(y);
    }
    void del(int x,int y){          // 缩点操作
        uni[x]=y;
        if(lc(x)) del(lc(x),y);
        if(rc(x)) del(rc(x),y);
    }
    void merge(int x,int y){
        if(x==y) return;
        makert(x);
        if(findrt(y)!=x)
            return fa[x]=y,void();
        del(rc(x),x);rc(x)=0;update(x);
    }
}
using namespace LCT;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ABC163F path pass i 解题报告]]></title>
        <id>https://parallelist-c.github.io/post/abc163f-path-pass-i-jie-ti-bao-gao/</id>
        <link href="https://parallelist-c.github.io/post/abc163f-path-pass-i-jie-ti-bao-gao/">
        </link>
        <updated>2020-12-27T06:07:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>给定一棵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点的树，树上每个点有一个颜色。对于每一种颜色，求有多少无向路径至少经过一次该颜色。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n\leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></p>
<h2 id="solution">Solution</h2>
<p>正难则反。考虑对于颜色 c ，假设将所有颜色为 c 的点删去，剩下的连通块有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个，大小分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_1,\cdots,s_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，那么颜色 c 的答案为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mfrac><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}-\sum_{i=1}^{k}\frac{s_i(s_i+1)}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>得到了一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的做法：暴力枚举颜色再 DFS 。</p>
<p>如何优化？可以发现，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\sum k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 级别的（断掉一个点至多贡献度数个连通块，每个点至多断一次）。对于每一个断后的连通块，其一定有且仅有一个深度最小的节点。我们用这个点来代表这个连通块。除了根以外，所有的点代表且仅代表一个连通块。</p>
<p>这个 trick 很实用。</p>
<p>发现了上述性质，就可以一遍 DFS 解决问题。DFS 同时对于每一种颜色维护一个单调栈，当递归完 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树后，与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 颜色相同且距离 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 最近的祖先节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 其代表的连通块就需要减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mtext>size</mtext><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\text{size}_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.81786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">size</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。若不存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 点，那么这个贡献需要算到根上。即对根单独开一个桶，下标表示颜色，统计所有非根的颜色而计入根的贡献的连通块。还需要注意的是，由于需要删去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 点，所以我们每遍历一棵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 的子树，就意味着一个连通块形成了，直接计算即可。</p>
<h2 id="code">Code</h2>
<pre><code class="language-c++">void DFS(int p,int from){
    stk[++top]=p;s[c[p]].push(top);sz[p]=1;
    for(int i=head[p];i;i=nt[i]){
        int v=to[i];
        if(v==from) continue;
        DFS(v,p);sz[p]+=sz[v];
        csz[p]+=sz[v];
        ans[c[p]]+=(1ll*csz[p]*(csz[p]+1)&gt;&gt;1);
        csz[p]=0;
    }
    --top;s[c[p]].pop();
    if(s[c[p]].size()) csz[stk[s[c[p]].top()]]-=sz[p];
    else rsz[c[p]]-=sz[p];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OI 回忆录]]></title>
        <id>https://parallelist-c.github.io/post/oi-hui-yi-lu/</id>
        <link href="https://parallelist-c.github.io/post/oi-hui-yi-lu/">
        </link>
        <updated>2020-12-21T14:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。</p>
</blockquote>
<hr>
<h2 id="part-0-序言">Part 0 序言</h2>
<p>看过很多人的退役记，明白自己终有一天要退役，只是没有想到这一天来得这么快。</p>
<p>现在是 12.03 ，距离 12.05 的联赛只剩下 2 天了。大考将近的时候，像我这样高不成低不就的凡人，虽然表面平静如水，紧张和莫名的激动是必然的。</p>
<p>Ysuperman 谈话：“紧张的话，不如把目光放长远一点，想想考试后会干什么，想想会到常规后会怎么样。”</p>
<p>想了想，没有奇迹出现的话，我考后第一件事就是写退役记了。周六考完，周日我多半不会有心情写，再之后又要学常规了，指不定就咕了。反正这几天做题也没什么大用处了，那就在把自己的 OI 生涯总结一下吧。</p>
<p>于是就有了这篇回忆录。</p>
<hr>
<h2 id="part-1-初中">Part 1 初中</h2>
<p>初二的某个周末，我来到了长沙市一中，上一堂信息学竞赛的体验课。</p>
<p>我来听这堂课，其实本来仅仅是好奇如何让电脑读入/输出数据。可惜老师没讲那么底层的东西。模模糊糊记得上课的老师杂讲了很多算法，其中印象最深的是一个最短路算法。算法的名字是 Dijkstra，由于原理是贪心，所以当时激起了我极大的兴趣，下课后就去找老师，尝试去证明贪心选择的正确性。老师在我证明的时候突然问我：</p>
<p>“你想加入信息学竞赛吗？”</p>
<p>我急于将自己的证明成果告诉老师，就敷衍了句好。当然，事后我也并没有反悔，现在我依旧不后悔。</p>
<p>上这堂课的老师正好就是 Ysuperman 。而在这堂课之后，我每个星期天都得来一中接受培训了。我的 OI 生涯或许就此开始了吧。</p>
<p>插句闲话，如果要准确时间的话，有个参考时间是我的洛谷账号注册时间： 2017-12-24 ，正好是 2017 年的平安夜呢​ 🌲 。​</p>
<hr>
<h2 id="part-2-高一">Part 2 高一</h2>
<p>虽然说接触 OI 是从初中开始的，但真正敢说是个 OIer 还是要到高一的寒假。</p>
<p>是的，在我高一上期的时候，作为一名高中竞赛生，我还不会网络流/平衡树/主席树/AAM/高斯消元...照这样下去，过完寒假我铁定退役。</p>
<p>不求能够在组内模拟赛中拔得头筹，我只希望自己能够跟紧大家的步伐，我只希望自己能再离组内的大佬们近一点，我只希望自己能有一个配得上 OIer 这个称号的实力。</p>
<p>幸好，我没有放弃这个寒假。从这个寒假开始，我开始写竞赛日记，总结自己每天学习的收获，第一次如此渴望自己变强。</p>
<p>最开始是字符串，从 KMP，Manacher 开始，什么 exKMP 啊， AAM 啊， SA 啊都来了 。</p>
<p>然后是数据结构，从树链剖分开始，什么 splay 啊，treap 啊，主席树啊，左偏树啊，点分治啊，CDQ 啊，整体二分啊， LCT 啊都来了。</p>
<p>接着学图论，从 Tarjan 开始，什么二分图啊，网络流啊，带花树啊，支配树啊都来了。</p>
<p>最后学数论，从 exgcd 开始，什么 (ex)CRT 啊， (ex)BSGS 啊，欧拉函数啊，Miller_Rabin 啊，Pollard_Rho 啊都来了。</p>
<p>有一说一，除了数论部分，其他的学习基本构建了我现在的 OI 知识体系。它们大大加深了我对于 OI 的理解。</p>
<p>高一上期的时候看到稍微难一点的知识都会直接放弃，想着等到高二再去学，蜷缩在自己学过的知识里混日子。可是，如果自己定义自己的能力只能学到 KMP ，那就永远也学不会 AAM ，永远也不会听说 SAM 和 PAM 啊。寒假的时候尝试去学习高级算法，才明白其实也没有那么难。学基础的算法是不难的，而且会带给人许多思路上的启发，会加深对 OI 的理解，这本就是每一个 OIer 都必须经历的洗礼啊。</p>
<p>如果能够重新学习竞赛，我必不会再以“难”为借口固步自封了，任何时候都不会，永远不会。</p>
<p>寒假于我的竞赛之路而言算是一个转折吧。无论是知识上还是态度上都有巨大的收获呢。寒假也可以说是我最痛并快乐着的吧，尽管我几乎每个凌晨都在啃博客/论文/算法书，但我的的确确能感觉到自己进步的速度。成就感是最好的动力源吧，它让我有信心去继续学习。</p>
<p>寒假还要感谢许多人，在我最困难的时期给予我帮助。没有 Daniel ，没有 Rain_morning ，没有 Anson ，我真不知道自己能不能掌握这么多东西，能不能撑过这个寒假。</p>
<p>寒假过后回来的学习，每天都挣扎在常规和竞赛之间。计算几何、分治分块、平面图... 讲课变多了，而且学习的东西也很核心。Boshi 和 YZH 精心准备了许多的资源。本来对于我而言是一次机遇的。</p>
<p>可惜我这个人没什么规划，时间管理又比较松散，常规竞赛一起来的时候往往顾此失彼。这段时间印象最深的是我那段时间习惯于两天晚自习做一道题，日记也是两天写一篇。如此低的效率，我不知道我究竟麻木成了什么样子才会如此颓废。纵向对比一下，在联赛前效率巅峰的一两个月里，一天晚自习至少是可以做两道题目的。</p>
<p>一两天的效率低是可以允许的，但是要清楚地意识到这个效率不正常，然后做出调整，绝不可以浑浑噩噩就过去了。整段的低效率的日子好似一把刀，在你日后忙碌时想起仍会隐隐作痛。</p>
<p>这段时间也不算完全没有收获吧。作为一个鶸，我找到了 Boshi 博客里的 dp 题，然后分专题地去训练 dp ，渴望能够进一步强化自己的 dp 。现在 dp 的大部分底子都是这段时间加上寒假前的时间打下来的吧。</p>
<p>6.21 参加了省选。Day1 两题暴力选手，Day2 三题暴力选手。爬了。</p>
<p>在忙忙碌碌地适应和调整中，高一过去了。强的人依旧一骑绝尘，菜的人依旧只能望尘莫及独自叹息。</p>
<hr>
<h2 id="part-3-高二">Part 3 高二</h2>
<p>信息学竞赛的高二是常规生的高三。暑假的时候就明白自己再不抓紧就等着退役了。</p>
<p>暑假整个机房都报了 zroi 的课。zroi 是以难著称的，还真是名副其实。</p>
<p>课程一开始就是计数。简单温习了组合恒等式后就开始了自然数幂求和啊，容斥原理啊，斯特林反演啊之类的，听得我迷迷糊糊的只懂了六七成。</p>
<p>本来以为这就是上课难度的极限了，结果两天后上来就是抽象代数， Burnside 啊，Polya 啊什么全来了。这次直接把我听懵了。课程反馈给 Ysuperman 写的是“基本没懂”。好像也是第一次给这样的反馈。</p>
<p>Ysuperman 回复我：“之前你们学习的时候，还在讲课时就能听个七八成，这不叫什么竞赛。真正的竞赛你上课是听不懂的，你要去适应。”</p>
<p>逼着自己在机房里抱着视频啃了两天群论。</p>
<p>学完数学又开始字符串了。这次学的字符串算法就比较 nb 了。学习了后缀树啊，SA 啊，SAM 啊，广义 SAM 啊什么的，还做了一堆习题。</p>
<p>学习 SAM 是真的痛苦，但是 SAM 的板子是真的好背，而且 SAM 的功能是真的香，之后做子串问题不是用 SAM 就是用 AAM 。</p>
<p>再往后就开始学习数论了，什么裴蜀定理啊，欧拉定理啊，原根啊，二次剩余啊之类的都来了。这些东西背后的定理现在已经忘了六七成了吧（悲，唯有一个 二次互反律 ，当时觉得这种屑定理不会有人拿来出题吧，结果例题就把我脸打肿了。现在这个律还记忆犹新。</p>
<p>zroi 培训完后恰好是 8.31 ， Ysuperman 说给我们放半天假。我， Z 神，丹尼和西哥一起去五一广场玩一下午，在城市英雄里面打了几个小时电游，还在某赛车比赛上拿了 rk1 。有一说一，丹尼打电游是真的强，把把第一，这姿态，像极了他校内模拟赛把把 AK 。晚上西哥没地方去，就跑我家去睡觉了（捂脸</p>
<p>第一次小团建，想起来还是很温馨呢 ❤️ 。</p>
<p>之后的大团建都是在各种考试后。CSP-S 模拟赛六点半下考，出考场时天已经晕染了一层晚霞，校门口的店子也基本都打烊了。一伙人只能出发到马路对面的 McDonald 去吃晚饭，路上一边讨论考试题目的做法 ，一边互相膜拜 Fake 。</p>
<blockquote>
<p>—— T2 可不可以 CDQ 分治套单调栈套树状数组做到两个 log 啊？</p>
<p>—— 怒切 T2 ，您太神了。但您的树状数组不是可以换成前缀和变成一个 log 嘛。</p>
<p>—— Orz 。xxx yyds 。</p>
</blockquote>
<p>暑假之后的学习就是自主学习了。当时好像是受了省选的影响，学习了矩阵树定理。学完自以为知识学的差不多了，头脑一热，就中二地去尝试板刷 BZOJ 。</p>
<p>Ysuperman：“刷省选题积累套路是好的，但我还是建议你按照专题来学习。”</p>
<p>剩下的日子到圣诞节一直在学习概率期望。圣诞节的后一天恰是 NOI 。</p>
<p>Day1 还好，虽然也不怎么会，但是暴力思路挺清晰的。Day2 直接自闭，T1 是什么神仙构造，T2 是什么神仙题面，T3 是什么神仙弦图。考完出成绩后， Day1 没挂分，但 Day2 实在是考得太差。没准 Day2 某道题的暴力有点思路就过银牌线了。不管了不管了。</p>
<p>九月份又回到常规上课，培训进度到了博弈论。</p>
<blockquote>
<p>游戏和的 SG 函数等于各个游戏的 Nim 和。</p>
</blockquote>
<p>SG 定理 yyds ，第一次学这个定理就被它震撼了。如此简洁实用功能强大的定理，如此繁琐复杂抽象奇怪的证明，居然是一个有机体。</p>
<p>剩下的时间，各人准备自己的讲课内容。我负责的内容是 计算几何 。想到之前 Boshi 讲计算几何时我一道练习还没写，眼泪就刷刷地往下流。</p>
<p>自己做题，自己备课的时光很充实。跟别人讲的东西，不能太难，也不能太容易，而且关键是自己肯定要学会。考虑到我的水平在组里偏菜，每天只得自己研究论文，尝试看懂里面的证明，尝试将结论用自己的话表述在课件中，并设身处地地思考如何让听众的感受更好。计算几何里两个大头是旋转卡壳和半平面交，我的 pdf 里前者是翻译了一篇国外的论文来讲解，后者我蒯了一篇集训队的论文来讲解（雾。但愿大家能够在听了我的讲课后对计算几何的理解更加深入吧。</p>
<p>讲完计算几何，Ysuperman 看我任务不重，又把我放进了图论组。在图论组里我的分工是点分树和生成树相关。</p>
<p>之前对点分树就有一定的心理准备，真正面对时还是感觉瑟瑟发抖。是个题码量至少 3kb 以上，离谱的还有 4.5kb 。而且尽管码农，思维也是精妙无比。</p>
<p>说到这里，我突然想到了 紫荆花之恋 。是了，这个题我可以吹一辈子，就算退役个两三年，面对学弟学妹我大概也可以矜持地吹这道题吧 😉 ​ 。（开个玩笑</p>
<figure data-type="image" tabindex="1"><img src="https://parallelist-c.github.io/post-images/1609485742982.png" alt="" loading="lazy"></figure>
<p><s>我怎么会说这道神题我做了整整一天呢 qwq</s></p>
<p>10.1 放了一天假，正巧赶上了模联城际会议。太幸运了 好开心。</p>
<p>10.2 学习了重构树。这东西很厉害，什么瓶颈路问题都可以直接秒了。学完大概有一种相见恨晚的感觉。</p>
<p>boshi 讲课，主题是数据结构。</p>
<blockquote>
<p>兄弟会背叛你，女人会离开你，金钱会诱惑你，生活会刁难你，只有 ds 不会，不会就是不会，怎么学都不会</p>
</blockquote>
<p>数据结构越学越神了，到最后看到题目推半天啥也不会，只能看完题解 sigh 一句：“这也能做？”  当时讲了很多题目，印象最深的是 CF710F String Set Queries 。通过二进制分组实现动态 AAM ，属实 nb 。</p>
<p>好了，接下来的日子由 scape 接管了。上来就是一手线性代数，很快啊。<s>我全都没防出去嗷</s></p>
<p>不过线代在 OI 中的确很重要，比高数的应用更广泛。上一堂课，什么线性相关啊，伴随矩阵啊，代数余子矩阵啊都来了。</p>
<p>10.5 这是我 OI 生涯中值得纪念的一天。我终于入多项式全家桶的坑了。</p>
<p>说不清对多项式全家桶什么感情，在高一的时候每次看到都想着高二再碰，高二的时候每次看到都想着找时间正面刚；当 scape 课上完，我发现我听得还不错时，我竟然有些泪目，就像见到了一个多年的老友，完成了一个多年的夙愿一样。</p>
<p>实现多项式全家桶的过程是我整个 OI 生涯中最有成就感的时候，现在想起来依然热泪盈眶。或许这并不仅仅是对于一个算法的理解的激动吧，这份感情里包含着一个长久处于瓶颈期的人在感知到自己实力上升时的欣喜。</p>
<p>有一说一，学 OI 的大部分时候重要的是做题和总结，但学数学时做好课堂笔记更重要。上课听不懂，只能先记好，下课再慢慢看。</p>
<p>学完多项式自然是做生成函数题目。生成函数真的是人类智慧之光。</p>
<blockquote>
<p>组合意义天地灭，代数推导保平安。</p>
</blockquote>
<p>这段时间趁着学各种组合计数题的契机，把二项式反演给学了。二项式反演的应用范围是真的广。</p>
<p>刷了一堆组合推式子+多项式优化的题目后，培训的方向又转到了数据结构。</p>
<p>10.15 学习了 fhq_treap ，第一次实现了可持久化平衡树。</p>
<p>10.20 学习了圆方树，无向图连通性问题大杀器。</p>
<p>10.23 写了道树上点分治斜率优化 dp 题（[NOI2014]购票）。写了整整一下午加一晚上，感觉头发又掉了不少。</p>
<p>本来培训的进度到这是学习图论的，然而图论前期的部分内容本来就是我讲的，于是对于我而言就是自习了。于是我那几天决定重学数论函数、莫比乌斯反演和杜教筛。独自学习数学的感觉很棒，就像一杯品质上乘的茶水，初尝时无味，过段时间心中便有清香。推式子的时候往往一两个小时什么代码也没有打，只是看着草稿纸上那一行行求和傻笑。切数学题真是 OI 中极有成就感的一件事呢。</p>
<p>学完数论再次进入图论。图论组要出两场 Educational Round 。神仙 xiaolilsq 一人出六题，txdy！！。</p>
<p>时光很快就到了 11 月份，我正式停止了知识点上的学习。每天就是考试考试考试......到现在对于考试也是有点麻木了。</p>
<p>再然后...再然后就是这个鶸要去面对人生中的最后一场联赛啦。我的竞赛生涯，开始于一场 NOIp ，即将结束于另一场 NOIp 。</p>
<hr>
<h2 id="part-4-noip2020">Part 4 NOIp2020</h2>
<p>以往的考试考前都是各种学，各种复习板子。直到这次联赛前，ZJY 在 U 盘里拷了个 counter-strike 1.6 。</p>
<p>单独一个人颓的时候很多，全组 8 个人开黑绝无仅有：</p>
<figure data-type="image" tabindex="2"><img src="https://parallelist-c.github.io/post-images/1609485755204.png" alt="" loading="lazy"></figure>
<p>考前的最后一次团建（？</p>
<p>NOIp：60+84+0+35=179 再努努力吧。</p>
]]></content>
    </entry>
</feed>